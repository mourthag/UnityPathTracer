#ifndef GEOMETRIES_H
#define GEOMETRIES_H

#include "Defines.compute"


//=======================================
//=-------------------------------------=
//=------------Geometries---------------=
//=-------------------------------------=
//=======================================

bool IntersectTriangle_MT97(Ray ray, inout float t, inout float3 barycentric, const float3 v1, const float3 v2, const float3 v3)
{
    float3 edge1 = v2 - v1;
    float3 edge2 = v3 - v1;
		
    float3 pvec = cross(ray.direction, edge2);
    float det = dot(edge1, pvec);
#ifdef BACKFACECULLING
    if (det < EPSILON)
        return false;
#else
    if (det < EPSILON && det > -EPSILON)
        return false;
#endif
		
    float invDet = 1.0f / det;
		
    float3 tvec = ray.origin - v1;
    barycentric.x = invDet * dot(tvec, pvec);
    if (barycentric.x < 0.0 || barycentric.x > 1.0)
        return false;

    float3 qvec = cross(tvec, edge1);
    barycentric.y = invDet * dot(ray.direction, qvec);
    if (barycentric.y < 0.0 || barycentric.y + barycentric.x > 1.0)
        return false;
		
    t = dot(edge2, qvec) * invDet;
    barycentric.z = 1.0 - barycentric.x - barycentric.y;

    barycentric.xyz = barycentric.zxy;
		
    return true;

}

interface iGeometry
{
    void Intersect(Ray ray, inout RayHit hit, inout float t);
};

struct Vertex {
    float3 position;
    float3 normal;
    float2 uv;
};

struct MeshObject
{
    float4x4 modelMatrix;
    float4x4 normalMatrix;
    int indexOffset;
    int triangleCount;
    int materialIndex;
};

StructuredBuffer<MeshObject> _MeshObjects;
StructuredBuffer<Vertex> _Vertices;
StructuredBuffer<int> _Indices;

/*  
 *  As the buffer cannot be easily converted into an array of mesh objects, we use this method to test intersection of all meshes.
 */
class Meshes : iGeometry
{
    
    void Intersect(Ray ray, inout RayHit hit, inout float t)
    {

        uint numMeshes, stride;
        _MeshObjects.GetDimensions(numMeshes, stride);

        float t_int = 1.#INF;

        for (uint meshID = 0; meshID < numMeshes; meshID++)
        {
            MeshObject mesh = _MeshObjects[meshID];
            for (int i = 0; i < mesh.triangleCount; i++)
            {
                const Vertex vert1 = _Vertices[_Indices[mesh.indexOffset + i * 3 + 0]];
                const Vertex vert2 = _Vertices[_Indices[mesh.indexOffset + i * 3 + 1]];
                const Vertex vert3 = _Vertices[_Indices[mesh.indexOffset + i * 3 + 2]];

                const float3 v1 = mul(mesh.modelMatrix, float4(vert1.position, 1)).xyz;
                const float3 v2 = mul(mesh.modelMatrix, float4(vert2.position, 1)).xyz;
                const float3 v3 = mul(mesh.modelMatrix, float4(vert3.position, 1)).xyz;
				
                float3 barycentric;
				
                if (IntersectTriangle_MT97(ray, t_int, barycentric, v1, v2, v3))
                {
                    if (t_int > 0 && t_int < t)
                    {
                        t = t_int;
                        hit.position = ray.origin + t * ray.direction;
                        hit.matID = mesh.materialIndex;

                        const float3 n1 = mul(mesh.normalMatrix, float4(vert1.normal, 1)).xyz;
                        const float3 n2 = mul(mesh.normalMatrix, float4(vert2.normal, 1)).xyz;
                        const float3 n3 = mul(mesh.normalMatrix, float4(vert3.normal, 1)).xyz;
                        hit.normal = normalize(barycentric.x * n1 + barycentric.y * n2 + barycentric.z * n3);

                        hit.uv = barycentric.x * vert1.uv + barycentric.y * vert2.uv + barycentric.z * vert3.uv;
                        hit.isFrontFace = dot(hit.normal, -ray.direction) > 0;
                    }
                }
            }
        }
    }
};

#ifdef USE_BVH

struct BVHNode
{
    float3 BoundsMaximum;
    float3 BoundsMinimum;
    int FirstPrimOffset, PrimCount, MeshIndex;
    int C0Index, C1Index;
};

StructuredBuffer<BVHNode> _BVHNodes;
int RootNode;

const static int STACKSIZE = 40;
void Push(int newEntry, inout int stack[STACKSIZE], inout int currentSize)
{
    if (currentSize >= STACKSIZE)
        return;
    stack[currentSize] = newEntry;
    currentSize++;
}
int Pop(inout int stack[STACKSIZE], inout int currentSize)
{
    if (currentSize <= 0)
        return -1;
    currentSize--;
    return stack[currentSize];
}

class BVH : iGeometry
{
    bool IntersectAABB(float3 bbMin, float3 bbMax, Ray ray)
    {
        float tx1 = (bbMin.x - ray.origin.x) * ray.inv_dir.x;
        float tx2 = (bbMax.x - ray.origin.x) * ray.inv_dir.x;

        float tmin = min(tx1, tx2);
        float tmax = max(tx1, tx2);

        float ty1 = (bbMin.y - ray.origin.y) * ray.inv_dir.y;
        float ty2 = (bbMax.y - ray.origin.y) * ray.inv_dir.y;

        tmin = max(tmin, min(ty1, ty2));
        tmax = min(tmax, max(ty1, ty2));

        float tz1 = (bbMin.z - ray.origin.z) * ray.inv_dir.z;
        float tz2 = (bbMax.z - ray.origin.z) * ray.inv_dir.z;

        tmin = max(tmin, min(tz1, tz2));
        tmax = min(tmax, max(tz1, tz2));

        return (tmax >= tmin);
    }

    void Intersect(Ray ray, inout RayHit hit, inout float t)
    {
        uint count, stride;
        _BVHNodes.GetDimensions(count, stride);

        int nodeStack[STACKSIZE] = (int[STACKSIZE])0;
        int stackSize = 0;
        float t_int = 1.#INF;

        //Intersect Root Node
        Push(RootNode, nodeStack, stackSize);

        while (stackSize > 0)
        {
            int nodeID = Pop(nodeStack, stackSize);
            BVHNode node = _BVHNodes[nodeID];
            //inner node
            if (IntersectAABB(node.BoundsMinimum, node.BoundsMaximum, ray))
            {
                if (node.PrimCount > 0)
                {
                    //leaf Node -> iterate over Prims
                    for (int i = 0; i < node.PrimCount; i++)
                    {                    
                        MeshObject mesh = _MeshObjects[node.MeshIndex];

                        const Vertex vert1 = _Vertices[_Indices[node.FirstPrimOffset + i * 3 + 0]];
                        const Vertex vert2 = _Vertices[_Indices[node.FirstPrimOffset + i * 3 + 1]];
                        const Vertex vert3 = _Vertices[_Indices[node.FirstPrimOffset + i * 3 + 2]];

                        const float3 v1 = mul(mesh.modelMatrix, float4(vert1.position, 1)).xyz;
                        const float3 v2 = mul(mesh.modelMatrix, float4(vert2.position, 1)).xyz;
                        const float3 v3 = mul(mesh.modelMatrix, float4(vert3.position, 1)).xyz;

                        float3 barycentric;

                        if (IntersectTriangle_MT97(ray, t_int, barycentric, v1, v2, v3))
                        {
                            if (t_int > 0 && t_int < t )
                            {
                                //return if ray is shadow ray and material is transparent
                                if(ray.type == RAYTYPE_SHADOW && any(_Materials[mesh.materialIndex].transmission))
                                    continue;

                                t = t_int;
                                hit.position = ray.origin + t * ray.direction;
                                hit.matID = mesh.materialIndex;

                                const float3 n1 = mul(mesh.normalMatrix, float4(vert1.normal, 0)).xyz;
                                const float3 n2 = mul(mesh.normalMatrix, float4(vert2.normal, 0)).xyz;
                                const float3 n3 = mul(mesh.normalMatrix, float4(vert3.normal, 0)).xyz;
                                hit.normal = normalize(barycentric.x * n1 + barycentric.y * n2 + barycentric.z * n3);

                                hit.uv = barycentric.x * vert1.uv + barycentric.y * vert2.uv + barycentric.z * vert3.uv;
                                hit.isFrontFace = dot(hit.normal, -ray.direction) > 0;
                            }
                        }
                    }


                }
                else {
                    //inner node
                    Push(node.C0Index, nodeStack, stackSize);
                    Push(node.C1Index, nodeStack, stackSize);
                }
            }


        }
    }
};
#endif
#endif