// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Defines.compute"
#include "Materials.compute"
#include "Geometries.compute"

RWTexture2D<float4> Result;

RWTexture2D<float4> PrevResult;
float _CurrentSample;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float2 _PixelOffset;

Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

bool _UseBVH;

Ray CreateCameraRay(float2 uv)
{
	//extract translation component from camera to World
	float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

	//get view-space direction from ndc
	float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
	//transform view-space direction to world-space direction
	direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
	//normalize the direction
	direction = normalize(direction);

	Ray ray = CreateRay(origin, direction, RAYTYPE_PRIMARY);
	return ray;
}

void Trace(Ray ray, iGeometry geometries[NUM_GEOMETRIES], inout RayHit bestHit, inout float t)
{
    t = 1.#INF;
	bestHit = CreateRayHit();
	for (int i = 0; i < NUM_GEOMETRIES; i++)
	{
		geometries[i].Intersect(ray, bestHit, t);
	}
}

float3 Shade(inout Ray ray, RayHit hit, float t, inout RayBuffer rb)
{	
	if (hit.matID < MAX_MATERIALS)
	{
		Ray scattered = CreateRay(float3(0.0f, 0.0f, 0.0f), float3(0.0f, 0.0f, 0.0f), RAYTYPE_REFLECTION);
		float3 attenuation = float3(0.0f, 0.0f, 0.0f);
        
        BufferMaterial mat;
        mat.Scatter(hit.matID, ray, hit, attenuation, scattered);

		if(scattered.type != RAYTYPE_INVALID && any(scattered.energy))
			rb.Push(scattered);

		return attenuation;
	}
	else {
		ray.energy = 0.0f;

		//render sky
		// Sample the skybox and write it
		float theta = acos(ray.direction.y) / -PI;
		float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
		return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
	}
}

[numthreads(8, 8, 1)]
void CSMain(uint3 groupid : SV_GroupThreadID, uint3 dpID : SV_DispatchThreadID)
{
	uint width, height;
	Result.GetDimensions(width, height);
	_Pixel = dpID.xy;

	Meshes m;
	BVH b;
	iGeometry geometries[NUM_GEOMETRIES];

	geometries[0] = b;

    // Transform pixel to [-1,1] range
    float2 uv = float2((dpID.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);

	// Get a ray for the UVs
	//Ray ray = CreateCameraRay(uv);
	RayHit hit = CreateRayHit();
	RayBuffer rb = CreateRayBuffer();
	rb.Push(CreateCameraRay(uv));

	float t = 1.#INF;	
        
    //Trace and Shade 
    float3 result = float3(0.0f, 0.0f, 0.0f);
	[unroll(10)]
	while (rb.currentSize > 0)
	{
		Ray ray = rb.Pop();
		Trace(ray, geometries, hit, t);
        result += ray.energy * Shade(ray, hit, t, rb);
	}

    //write result
    float3 prevResult = PrevResult[dpID.xy].rgb;
    float3 finalResult = (prevResult * (_CurrentSample) + result) / (_CurrentSample + 1.0);
    Result[dpID.xy] = float4(finalResult, 1.0f);
    PrevResult[dpID.xy] = float4(finalResult, 1.0f);


}
