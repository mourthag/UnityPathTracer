#ifndef LIGHTS_H
#define LIGHTS_H

#include "Defines.compute"
#include "Geometries.compute"

void CastShadowRay(Ray ray, inout RayHit bestHit, inout float t)
{
    t = 1.#INF;
	bestHit = CreateRayHit();
		
#ifdef USE_BVH
	BVH b;
	iGeometry geometry = b;
#else
	Meshes m;
	iGeometry geometry = m;
#endif
	geometry.Intersect(ray, bestHit, t);
}

//=======================================
//=-------------------------------------=
//=------------Light Types--------------=
//=-------------------------------------=
//=======================================

interface Light{

    //should return a direction that points from pos to a point on the light source 
    float3 Sample(float3 pos);

    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t);

    float3 GetContribution(Ray ray);
};

class PointLight : Light {
    float3 Position;
    float3 Intensity;
    
    float3 Sample(float3 pos){
        return normalize(Position - pos);
    }

    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t > length(Position - shadowRay.origin);
    }

    float3 GetContribution(Ray ray){
        float3 contribution;

        //Check shadowing?

        const float distance = length(Position- ray.origin);
        //Prevent inf -> Bakery Falloff
        contribution = Intensity / pow(max(distance, 0.01), 2.0);

        return contribution;
    }

};

class DirectionalLight : Light {
    float3 Direction;
    float3 Intensity;

    float3 Sample(float3 pos){
        return normalize(-Direction);
    }
    
    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t == 1.#INF;
    }

    float3 GetContribution(Ray ray){

        //Check Shadowing
        return Intensity;
    }
};

//=======================================
//=-------------------------------------=
//=------------LightBuffer--------------=
//=-------------------------------------=
//=======================================

struct LightBufferObject{
    int Type;
    float3 Position;
    float3 Intensity;
};


StructuredBuffer<LightBufferObject> _Lights;

int GetRandomLightID()
{
    uint count, stride;
	_Lights.GetDimensions(count, stride);

    if(count == 0)
        return -1;
    return randInt(0, count);
}

float3 SampleLight(int id, float3 pos)
{

    const LightBufferObject light = _Lights[id];
    //PointLight
    if(light.Type == 0)
    {
        PointLight pl;
        pl.Position = light.Position;
        pl.Intensity = light.Intensity;
        return pl.Sample(pos);
    }
    //SpotLight
    else if(light.Type == 1)
    {
        //TODO
        PointLight sl;
        sl.Position = light.Position;
        sl.Intensity = light.Intensity;
        return sl.Sample(pos);

    }
    //DirectionalLight
    else if(light.Type == 2)
    {
        DirectionalLight dl;
        dl.Direction = light.Position;
        dl.Intensity = light.Intensity;
        return dl.Sample(pos);

    }
    PointLight pl;
    pl.Position = light.Position;
    pl.Intensity = light.Intensity;
    return pl.Sample(pos);
}

float3 GetContribution(int id, Ray ray)
{

    float distance;
    RayHit hit;
    CastShadowRay(ray, hit, distance);

    const LightBufferObject light = _Lights[id];
    //PointLight
    if(light.Type == 0)
    {
        PointLight pl;
        pl.Position = light.Position;
        pl.Intensity = light.Intensity;
        return pl.GetContribution(ray) * pl.IsVisible(ray, hit, distance);
    }
    //SpotLight
    else if(light.Type == 1)
    {
        //TODO
        PointLight sl;
        sl.Position = light.Position;
        sl.Intensity = light.Intensity;
        return sl.GetContribution(ray) * sl.IsVisible(ray, hit, distance);

    }
    //DirectionalLight
    else if(light.Type == 2)
    {
        DirectionalLight dl;
        dl.Direction = light.Position;
        dl.Intensity = light.Intensity;
        return dl.GetContribution(ray) * dl.IsVisible(ray, hit, distance);

    }
    PointLight pl;
    pl.Position = light.Position;
    pl.Intensity = light.Intensity;
    return pl.GetContribution(ray) * pl.IsVisible(ray, hit, distance);
}

#endif