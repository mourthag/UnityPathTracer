#ifndef LIGHTS_H
#define LIGHTS_H

#include "Defines.compute"
#include "Geometries.compute"

void CastShadowRay(Ray ray, inout RayHit bestHit, inout float t)
{
    t = 1.#INF;
	bestHit = CreateRayHit();
		
#ifdef USE_BVH
	BVH b;
	iGeometry geometry = b;
#else
	Meshes m;
	iGeometry geometry = m;
#endif
	geometry.Intersect(ray, bestHit, t);
}


struct LightBufferObject{
    int Type;
    float3 Position;
    float3 Direction;
    float3 Intensity;
    float SpotAngle;
};


StructuredBuffer<LightBufferObject> _Lights;

//=======================================
//=-------------------------------------=
//=------------Light Types--------------=
//=-------------------------------------=
//=======================================

interface Light{

    void Init(LightBufferObject obj);

    //should return a direction that points from pos to a point on the light source 
    float3 Sample(float3 pos);

    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t);

    float3 GetContribution(Ray ray);
};

class PointLight : Light {
    float3 Position;
    float3 Intensity;
    
    void Init(LightBufferObject obj)
    {
        Position = obj.Position;
        Intensity = obj.Intensity;
    }
    
    float3 Sample(float3 pos){
        return normalize(Position - pos);
    }

    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t > length(Position - shadowRay.origin);
    }

    float3 GetContribution(Ray ray){
        float3 contribution;

        const float distance = length(Position- ray.origin);
        
        contribution = Intensity / pow(max(distance, 0.01), 2.0);

        return contribution;
    }

};

class DirectionalLight : Light {
    float3 Direction;
    float3 Intensity;
    
    void Init(LightBufferObject obj)
    {
        Direction = obj.Position;
        Intensity = obj.Intensity;
    }

    float3 Sample(float3 pos){
        return normalize(-Direction);
    }
    
    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t == 1.#INF;
    }

    float3 GetContribution(Ray ray){

        //Check Shadowing
        return Intensity;
    }
};

class SpotLight : Light {
    float3 Position;
    float3 Direction;
    float angle;
    float3 Intensity;
    
    
    void Init(LightBufferObject obj)
    {
        Position = obj.Position;
        Direction = obj.Direction;
        Intensity = obj.Intensity;
        angle = obj.SpotAngle;
    }


    float3 Sample(float3 pos){
        return normalize(Position - pos);
    }

    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t > length(Position - shadowRay.origin);
    }

    float3 GetContribution(Ray ray){
        float3 contribution;

        const float theta = dot(ray.direction, -Direction);
        const float cutOff = cos(radians(angle));

        if(theta > cutOff)
        {
            const float distance = length(Position- ray.origin);
            
            contribution = Intensity / pow(max(distance, 0.01), 2.0);

            return contribution;
        }
        else 
            return (float3)0;

    }
};

//=======================================
//=-------------------------------------=
//=------------LightBuffer--------------=
//=-------------------------------------=
//=======================================

int GetRandomLightID()
{
    uint count, stride;
	_Lights.GetDimensions(count, stride);

    if(count == 0)
        return -1;
    return randInt(0, count);
}

float3 SampleLight(int id, float3 pos)
{

    const LightBufferObject light = _Lights[id];
    //PointLight
    if(light.Type == 0)
    {
        PointLight pl;
        pl.Init(light);
        return pl.Sample(pos);
    }
    //SpotLight
    else if(light.Type == 1)
    {
        SpotLight sl;
        sl.Init(light);
        return sl.Sample(pos);

    }
    //DirectionalLight
    else if(light.Type == 2)
    {
        DirectionalLight dl;
        dl.Init(light);
        return dl.Sample(pos);

    }
    PointLight pl;
    pl.Init(light);
    return pl.Sample(pos);
}

float3 GetContribution(int id, Ray ray)
{

    float distance;
    RayHit hit;
    CastShadowRay(ray, hit, distance);

    const LightBufferObject light = _Lights[id];
    //PointLight
    if(light.Type == 0)
    {
        PointLight pl;
        pl.Init(light);
        return pl.GetContribution(ray) * pl.IsVisible(ray, hit, distance);
    }
    //SpotLight
    else if(light.Type == 1)
    {
        SpotLight sl;
        sl.Init(light);
        return sl.GetContribution(ray) * sl.IsVisible(ray, hit, distance);

    }
    //DirectionalLight
    else if(light.Type == 2)
    {
        DirectionalLight dl;
        dl.Init(light);
        return dl.GetContribution(ray) * dl.IsVisible(ray, hit, distance);

    }
    PointLight pl;
    pl.Init(light);
    return pl.GetContribution(ray) * pl.IsVisible(ray, hit, distance);
}

#endif