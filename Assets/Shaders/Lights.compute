#ifndef LIGHTS_H
#define LIGHTS_H

#include "Defines.compute"
#include "Geometries.compute"

//#define LIGHT_PRIMARY_VISIBLE

void CastShadowRay(Ray ray, inout RayHit bestHit, inout float t)
{
    t = 1.#INF;
	bestHit = CreateRayHit();
		
    ray.type = RAYTYPE_SHADOW;
#ifdef USE_BVH
	BVH b;
	iGeometry geometry = b;
#else
	Meshes m;
	iGeometry geometry = m;
#endif
	geometry.Intersect(ray, bestHit, t);
}


struct LightBufferObject{
    int Type;
    float3 Position;
    float3 Direction;
    float3 Intensity;
    float SpotAngle;
    float2 AreaSize;
};


StructuredBuffer<LightBufferObject> _Lights;

//=======================================
//=-------------------------------------=
//=------------Light Types--------------=
//=-------------------------------------=
//=======================================

interface Light{

    void Init(LightBufferObject obj);

    //should return a direction that points from pos to a point on the light source 
    float3 Sample(float3 pos);

    void Intersect(Ray ray, inout RayHit hit, inout float t);
    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t);

    float3 GetContribution(Ray ray);
};

class PointLight : Light {
    float3 Position;
    float3 Intensity;
    
    void Init(LightBufferObject obj)
    {
        Position = obj.Position;
        Intensity = obj.Intensity;
    }
    
    float3 Sample(float3 pos){
        return normalize(Position - pos);
    }

    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t > length(Position - shadowRay.origin);
    }

    float3 GetContribution(Ray ray){
        float3 contribution;

        if(ray.type == RAYTYPE_PRIMARY)
        {
            return Intensity;
        }

        const float distance = length(Position- ray.origin);
        
        contribution = Intensity / pow(max(distance, 0.01), 2.0);

        return contribution;
    }

    void Intersect(Ray ray, inout RayHit hit, inout float t)
    {
#ifndef LIGHT_PRIMARY_VISIBLE
    if(ray.type == RAYTYPE_PRIMARY)
            return;
#endif

        float3 distance = Position - ray.origin;
        if(dot(normalize(distance), ray.direction) > 0.99)
        {
            float t_intersect = length(distance);
            if(t_intersect > 0 && t_intersect < t)
            {
                t = t_intersect;
                hit.lightContrib =  GetContribution(ray);
            }
        }
    }
};

class DirectionalLight : Light {
    float3 Direction;
    float3 Intensity;
    
    void Init(LightBufferObject obj)
    {
        Direction = obj.Position;
        Intensity = obj.Intensity;
    }

    float3 Sample(float3 pos){
        return normalize(Direction);
    }
    
    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t == 1.#INF;
    }

    float3 GetContribution(Ray ray){

        return Intensity;
    }

    void Intersect(Ray ray, inout RayHit hit, inout float t)
    {
#ifndef LIGHT_PRIMARY_VISIBLE
    if(ray.type == RAYTYPE_PRIMARY)
            return;
#endif

        if(abs(dot(Direction, ray.direction)) < 0.99)
        {
            if(t == 1.#INF)
            {
                hit.lightContrib = GetContribution(ray);
            }
        }
    }
};

class SpotLight : Light {
    float3 Position;
    float3 Direction;
    float angle;
    float3 Intensity;
    
    
    void Init(LightBufferObject obj)
    {
        Position = obj.Position;
        Direction = obj.Direction;
        Intensity = obj.Intensity;
        angle = obj.SpotAngle;
    }


    float3 Sample(float3 pos){
        return normalize(Position - pos);
    }

    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t > length(Position - shadowRay.origin);
    }

    float3 GetContribution(Ray ray){
        float3 contribution;

        const float theta = dot(ray.direction, -Direction);
        const float cutOff = cos(radians(angle));

        if(theta > cutOff)
        {
            if(ray.type == RAYTYPE_PRIMARY)
            {
                return Intensity;
            }

            const float distance = length(Position- ray.origin);
            
            contribution = Intensity / pow(max(distance, 0.01), 2.0);

            return contribution;
        }
        else 
            return (float3)0;

    }
        
    void Intersect(Ray ray, inout RayHit hit, inout float t)
    {
#ifndef LIGHT_PRIMARY_VISIBLE
    if(ray.type == RAYTYPE_PRIMARY)
            return;
#endif

        float3 distance = Position - ray.origin;
        if(dot(normalize(distance), ray.direction) > 1.0-EPSILON)
        {
            float t_intersect = length(distance);
            if(t_intersect > 0 && t_intersect < t)
            {
                t = t_intersect;
                hit.lightContrib =  GetContribution(ray);
            }
        }
    }
};

class AreaLight : Light {
    float3 Position;
    float3 Direction;
    float2 AreaSize;
    float3 Intensity;
    
    
    void Init(LightBufferObject obj)
    {
        Position = obj.Position;
        Direction = normalize(obj.Direction);
        Intensity = obj.Intensity;
        AreaSize = obj.AreaSize.yx;
    }


    float3 Sample(float3 pos){

        const float x = rand() * AreaSize.x - AreaSize.x / 2.0;
        const float y = rand() * AreaSize.y - AreaSize.y / 2.0; 
        const float z = 0;

        const float3x3 tangentSpace = GetTangentSpace(Direction);
        const float3 offset = mul(tangentSpace, float3(x,y,z));

        return normalize(Position + offset - pos);
    }

    bool IsVisible(Ray shadowRay, RayHit shadowRayIntersection, float t)
    {
        return t > length(Position - shadowRay.origin);
    }

    float3 GetContribution(Ray ray, RayHit hit){
        float3 contribution;

        if(ray.type == RAYTYPE_PRIMARY)
        {
            return Intensity;
        }

        const float distance = length(hit.position- ray.origin);
        
        contribution = Intensity / pow(max(distance, 0.01), 2.0);

        return contribution;

    }

    void Intersect(Ray ray, inout RayHit hit, inout float t)
    {
#ifndef LIGHT_PRIMARY_VISIBLE
    if(ray.type == RAYTYPE_PRIMARY)
            return;
#endif

        const float denom = dot(-Direction, ray.direction);
        if(denom > EPSILON)
        {
            const float3 dist = Position - ray.origin;
            const float t_intersect = dot(dist, -Direction) / denom;

            const float3 hitPosition  = ray.origin + t_intersect * ray.direction; 
            const float3x3 tangentSpace = GetTangentSpace(Direction);
            const float3 v1 = mul(tangentSpace, float3(1,0,0));
            const float3 v2 = mul(tangentSpace, float3(0,1,0));

            if(t_intersect > 0 && t_intersect < t
                &&  abs(dot(hitPosition - Position, v1)) < AreaSize.x / 2.0
                &&  abs(dot(hitPosition - Position, v2)) < AreaSize.y / 2.0)
            {
                t = t_intersect;
                hit.position = hitPosition;
                hit.lightContrib = GetContribution(ray, hit);
            }
        }
    }

    float3 GetContribution(Ray ray)
    {
        float t = 1.#INF;
        RayHit hit = CreateRayHit();
        Intersect(ray, hit, t);
        return hit.lightContrib;
    }
};

//=======================================
//=-------------------------------------=
//=------------LightBuffer--------------=
//=-------------------------------------=
//=======================================

void IntersectLights(Ray ray, inout RayHit hit, inout float t)
{
    
    uint count, stride;
	_Lights.GetDimensions(count, stride);
    for(uint lightId = 0; lightId < count; lightId++)
    {
        const LightBufferObject light = _Lights[lightId];
        //PointLight
        if(light.Type == 0)
        {
            PointLight pl;
            pl.Init(light);
            pl.Intersect(ray, hit, t);
        }
        //SpotLight
        else if(light.Type == 1)
        {
            SpotLight sl;
            sl.Init(light);
            sl.Intersect(ray, hit, t);

        }
        //DirectionalLight
        else if(light.Type == 2)
        {
            DirectionalLight dl;
            dl.Init(light);
            dl.Intersect(ray, hit, t);

        }    
        //AreaLight
        else if(light.Type == 3)
        {
            AreaLight al;
            al.Init(light);
            al.Intersect(ray, hit, t);

        }
        PointLight pl;
        pl.Init(light);
        pl.Intersect(ray, hit, t);
    }
}

int GetRandomLightID()
{
    uint count, stride;
	_Lights.GetDimensions(count, stride);

    if(count == 0)
        return -1;
    return randInt(0, count);
}

float3 SampleLight(int id, float3 pos)
{

    const LightBufferObject light = _Lights[id];
    //PointLight
    if(light.Type == 0)
    {
        PointLight pl;
        pl.Init(light);
        return pl.Sample(pos);
    }
    //SpotLight
    else if(light.Type == 1)
    {
        SpotLight sl;
        sl.Init(light);
        return sl.Sample(pos);

    }
    //DirectionalLight
    else if(light.Type == 2)
    {
        DirectionalLight dl;
        dl.Init(light);
        return dl.Sample(pos);

    }    
    //AreaLight
    else if(light.Type == 3)
    {
        AreaLight al;
        al.Init(light);
        return al.Sample(pos);

    }
    PointLight pl;
    pl.Init(light);
    return pl.Sample(pos);
}

float3 GetContribution(int id, Ray ray)
{

    float distance;
    RayHit hit;
    CastShadowRay(ray, hit, distance);

    const LightBufferObject light = _Lights[id];
    //PointLight
    if(light.Type == 0)
    {
        PointLight pl;
        pl.Init(light);
        return pl.GetContribution(ray) * pl.IsVisible(ray, hit, distance);
    }
    //SpotLight
    else if(light.Type == 1)
    {
        SpotLight sl;
        sl.Init(light);
        return sl.GetContribution(ray) * sl.IsVisible(ray, hit, distance);

    }
    //DirectionalLight
    else if(light.Type == 2)
    {
        DirectionalLight dl;
        dl.Init(light);
        return dl.GetContribution(ray) * dl.IsVisible(ray, hit, distance);

    }
    //DirectionalLight
    else if(light.Type == 3)
    {
        AreaLight al;
        al.Init(light);
        return al.GetContribution(ray) * al.IsVisible(ray, hit, distance);

    }
    PointLight pl;
    pl.Init(light);
    return pl.GetContribution(ray) * pl.IsVisible(ray, hit, distance);
}

#endif