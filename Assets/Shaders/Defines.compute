#ifndef DEFINES_H
#define DEFINES_H

float2 _Pixel;
float _Seed;

static const float PI = 3.14159265f;
static const float EPSILON = 1e-8;

const static int MAX_DEPTH = 24;
const static int NUM_GEOMETRIES = 1;
const static int MAX_MATERIALS = 16;

#define USE_RR
#ifdef USE_RR
const static float RR_SURV_CHANCE = 0.8;
#else
const static float RR_SURV_CHANCE = 1.0;
#endif

//=======================================
//=-------------------------------------=
//=---------------Math------------------=
//=-------------------------------------=
//=======================================

float rand()
{
	float result = frac(sin(_Seed / 100.0f * dot(_Pixel, float2(12.9898f, 78.233f))) * 43758.5453f);
	_Seed += 1.0f;
	return result;
}

float sdot(float3 x, float3 y, float f = 1.0f)
{
	return saturate(dot(x, y) * f);
}

float energy(float3 color)
{
	return dot(color, 1.0f / 3.0f);
}

float3x3 GetTangentSpace(float3 normal)
{
	// Choose a helper vector for the cross product
	float3 helper = float3(1, 0, 0);
	if (abs(normal.x) > 0.99f)
		helper = float3(0, 0, 1);
	// Generate vectors
	float3 tangent = normalize(cross(normal, helper));
	float3 binormal = normalize(cross(normal, tangent));
	return float3x3(tangent, binormal, normal);
}

float3 SampleHemisphere(float3 normal, float alpha = 0.0f)
{
    // Sample the hemisphere, where alpha determines the kind of the sampling
    float cosTheta = pow(rand(), 1.0f / (alpha + 1.0f));
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
    float phi = 2 * PI * rand();
    float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    // Transform direction to world space
    return mul(tangentSpaceDir, GetTangentSpace(normal));
}

float3 SampleCT(const float3 reflected, const float roughness) {
	const float eta1 = rand();
	const float eta2 = rand();

	//todo optimize by removing trigo methods (see sin(atan(x)))
	const float theta = atan(roughness * sqrt(eta1)/sqrt(1-eta1));
	const float cosTheta = cos(theta);
	const float sinTheta = sin(theta);
	const float phi = 2 * PI * eta2;

	const float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    // Transform direction to world space
    return mul(tangentSpaceDir, GetTangentSpace(reflected));
}

//=======================================
//=-------------------------------------=
//=---------------Rays------------------=
//=-------------------------------------=
//=======================================

static const int RAYTYPE_PRIMARY = 0;
static const int RAYTYPE_REFLECTION = 1;
static const int RAYTYPE_TRANSMISSION = 2;
static const int RAYTYPE_INVALID = -1;

struct Ray {
	float3 origin;
	float3 direction;
	float3 energy;
	float3 inv_dir;
	int type;

	bool isInvalid()
	{
		return type == RAYTYPE_INVALID || !any(energy);
	}
};

Ray CreateInvalidRay() {
	Ray ray;
	ray.origin = (float3)0;
	ray.direction = (float3)0;
	ray.inv_dir = (float3)0;
	ray.energy = (float3)0;
	ray.type = RAYTYPE_INVALID;
	return ray;
}

Ray CreateRay(float3 origin, float3 direction, int type) {
	Ray ray;
	ray.origin = origin;
	ray.direction = direction;
	ray.energy = float3(1.0f, 1.0f, 1.0f);
	ray.inv_dir = 1.0 / direction;
	ray.type = type;
	return ray;
}

struct RayHit {
	float3 position;
	float3 normal;
	float2 uv;
	int matID;
	bool isFrontFace;
};

RayHit CreateRayHit() {
	RayHit hit;
	hit.position = float3(0.0f, 0.0f, 0.0f);
	hit.normal = float3(0.0f, 0.0f, 0.0f);
	hit.uv = float2(0.0f, 0.0f);
	hit.matID = MAX_MATERIALS;
	return hit;						  
}

static const int RAYBUFFER_SIZE = MAX_DEPTH * 3;
class RayBuffer {

	Ray buffer[RAYBUFFER_SIZE];
	int currentSize;

	void Push(Ray newEntry)
	{
		if (newEntry.isInvalid() || currentSize >= RAYBUFFER_SIZE)
			return;
		buffer[currentSize] = newEntry;
		currentSize++;
	}

	Ray Pop()
	{
		currentSize--;		
		if (currentSize < 0)
		{
			currentSize = 0;
			return CreateInvalidRay();
		}
		return buffer[currentSize];
	}

	bool isEmpty()
	{
		return currentSize == 0;
	}
};

RayBuffer CreateRayBuffer() {
	RayBuffer b;
	b.buffer = (Ray[RAYBUFFER_SIZE])0;
	b.currentSize = 0;

	return b;
}

#endif