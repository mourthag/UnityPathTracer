#ifndef DEFINES_H
#define DEFINES_H

float2 _Pixel;
float _Seed;

static const float PI = 3.14159265f;
static const float EPSILON = 1e-8;

const static int MAX_DEPTH = 16;
const static int NUM_GEOMETRIES = 1;
const static int MAX_MATERIALS = 16;

//=======================================
//=-------------------------------------=
//=---------------Math------------------=
//=-------------------------------------=
//=======================================

float rand()
{
	float result = frac(sin(_Seed / 100.0f * dot(_Pixel, float2(12.9898f, 78.233f))) * 43758.5453f);
	_Seed += 1.0f;
	return result;
}

float3x3 GetTangentSpace(float3 normal)
{
	// Choose a helper vector for the cross product
	float3 helper = float3(1, 0, 0);
	if (abs(normal.x) > 0.99f)
		helper = float3(0, 0, 1);
	// Generate vectors
	float3 tangent = normalize(cross(normal, helper));
	float3 binormal = normalize(cross(normal, tangent));
	return float3x3(tangent, binormal, normal);
}

float3 SampleHemisphere(float3 normal)
{
	// Uniformly sample hemisphere direction
	float cosTheta = rand();
	float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
	float phi = 2 * PI * rand();
	float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
	// Transform direction to world space
	return mul(tangentSpaceDir, GetTangentSpace(normal));
}


//=======================================
//=-------------------------------------=
//=---------------Rays------------------=
//=-------------------------------------=
//=======================================

static const int RAYTYPE_PRIMARY = 0;
static const int RAYTYPE_REFLECTION = 1;
static const int RAYTYPE_TRANSMISSION = 2;
static const int RAYTYPE_INVALID = -1;

struct Ray {
	float3 origin;
	float3 direction;
	float3 energy;
	float3 inv_dir;
	int type;
};

Ray CreateInvalidRay() {
	Ray ray;
	ray.origin = (float3)0;
	ray.direction = (float3)0;
	ray.inv_dir = (float3)0;
	ray.energy = (float3)0;
	ray.type = RAYTYPE_INVALID;
	return ray;
}

Ray CreateRay(float3 origin, float3 direction, int type) {
	Ray ray;
	ray.origin = origin;
	ray.direction = direction;
	ray.energy = float3(1.0f, 1.0f, 1.0f);
	ray.inv_dir = 1.0 / direction;
	ray.type = type;
	return ray;
}

struct RayHit {
	float3 position;
	float3 normal;
	int matID;
};

RayHit CreateRayHit() {
	RayHit hit;
	hit.position = float3(0.0f, 0.0f, 0.0f);
	hit.normal = float3(0.0f, 0.0f, 0.0f);
	hit.matID = MAX_MATERIALS;
	return hit;						  
}

static const int RAYBUFFER_SIZE = MAX_DEPTH * 3;
class RayBuffer {

	Ray buffer[RAYBUFFER_SIZE];
	int currentSize;

	void Push(Ray newEntry)
	{
		if (currentSize >= RAYBUFFER_SIZE)
			return;
		buffer[currentSize] = newEntry;
		currentSize++;
	}

	Ray Pop()
	{
		currentSize--;		
		if (currentSize < 0)
		{
			currentSize = 0;
			return CreateInvalidRay();
		}
		return buffer[currentSize];
	}

	bool isEmpty()
	{
		return currentSize == 0;
	}
};

RayBuffer CreateRayBuffer() {
	RayBuffer b;
	b.buffer = (Ray[RAYBUFFER_SIZE])0;
	b.currentSize = 0;

	return b;
}

#endif