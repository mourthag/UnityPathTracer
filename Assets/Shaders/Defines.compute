#ifndef DEFINES_H
#define DEFINES_H
const static int MAX_MATERIALS = 16;

float2 _Pixel;
float _Seed;

static const float PI = 3.14159265f;
static const float EPSILON = 1e-8;

//=======================================
//=-------------------------------------=
//=---------------Math------------------=
//=-------------------------------------=
//=======================================

float rand()
{
	float result = frac(sin(_Seed / 100.0f * dot(_Pixel, float2(12.9898f, 78.233f))) * 43758.5453f);
	_Seed += 1.0f;
	return result;
}

float3x3 GetTangentSpace(float3 normal)
{
	// Choose a helper vector for the cross product
	float3 helper = float3(1, 0, 0);
	if (abs(normal.x) > 0.99f)
		helper = float3(0, 0, 1);
	// Generate vectors
	float3 tangent = normalize(cross(normal, helper));
	float3 binormal = normalize(cross(normal, tangent));
	return float3x3(tangent, binormal, normal);
}

float3 SampleHemisphere(float3 normal)
{
	// Uniformly sample hemisphere direction
	float cosTheta = rand();
	float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
	float phi = 2 * PI * rand();
	float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
	// Transform direction to world space
	return mul(tangentSpaceDir, GetTangentSpace(normal));
}

//=======================================
//=-------------------------------------=
//=---------------Rays------------------=
//=-------------------------------------=
//=======================================

struct Ray {
	float3 origin;
	float3 direction;
	float3 energy;
	float3 inv_dir;
};

Ray CreateRay(float3 origin, float3 direction) {
	Ray ray;
	ray.origin = origin;
	ray.direction = direction;
	ray.energy = float3(1.0f, 1.0f, 1.0f);
	ray.inv_dir = 1.0 / direction;
	return ray;
}

struct RayHit {
	float3 position;
	float3 normal;
	int matID;
};

RayHit CreateRayHit() {
	RayHit hit;
	hit.position = float3(0.0f, 0.0f, 0.0f);
	hit.normal = float3(0.0f, 0.0f, 0.0f);
	hit.matID = MAX_MATERIALS;
	return hit;						  
}

#endif