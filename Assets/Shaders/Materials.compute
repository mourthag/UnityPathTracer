#ifndef MATERIALS_H
#define MATERIALS_H

#include "Defines.compute"

//=======================================
//=-------------------------------------=
//=----------Util Methods---------------=
//=-------------------------------------=
//=======================================

float3 refract(float3 inc_dir, float3 normal, float ior_qout)
{
    float cos_theta = min(dot(-inc_dir, normal), 1.0);
    float3 r_out_perp = ior_qout * (inc_dir + cos_theta * normal);
    float3 r_out_parallel = -sqrt(abs(1.0 - dot(r_out_perp, r_out_perp))) * normal;
    return r_out_perp + r_out_parallel;
}

float Schlicks_Approx(float cosine, float refractive_index)
{
    float r0 = (1.0 - refractive_index) / (1.0 + refractive_index);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);
}

float3 fresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0 - F0) * pow(saturate(1.0 - cosTheta), 5.0);
}

float3 halfVector(const float3 l, const float3 v) {
    return normalize(l + v);
}

float NDF_GGX(const float3 N, const float3 H, const float alpha)
{
    const float a2 = alpha * alpha;
    const float NdotH = max(dot(N, H), 0.0);
    float denom = (NdotH * NdotH * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return a2 / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    //TODO different k for sampling strats?
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;

    float nom = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / denom;
}

float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
    float ggx2 = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

//=======================================
//=-------------------------------------=
//=------------Materials----------------=
//=-------------------------------------=
//=======================================

interface iMaterial
{
    bool Scatter(Ray inRay, inout RayHit hit, inout float3 attenuation, inout RayBuffer rb);
};


struct MaterialBufferObject
{
    float3 albedo, emission, transmission;
    float ior, metalness, roughness;
    int albedoTexId, emissionTexId, normalTexId, MRTexId;
};


StructuredBuffer<MaterialBufferObject> _Materials;

Texture2DArray<float4> _MaterialAlbedoTextures;
SamplerState sampler_MaterialAlbedoTextures;
Texture2DArray<float4> _MaterialNormalTextures;
SamplerState sampler_MaterialNormalTextures;
Texture2DArray<float4> _MaterialMRTextures;
SamplerState sampler_MaterialMRTextures;
Texture2DArray<float4> _MaterialEmissionTextures;
SamplerState sampler_MaterialEmissionTextures;

#include "Lights.compute"

class BufferMaterial
{
    /*void EvaluatePhong(const MaterialBufferObject mat, const Ray inRay, const RayHit hit, inout RayBuffer rb)
    {
        const float sum = energy(mat.specular) + energy(mat.albedo);
        const float specChance = energy(mat.specular) / sum;
        const float diffChance = energy(mat.albedo) / sum;

        const float3 rayOrigin = hit.position + hit.normal * 0.0001f;
        const float3 reflected = reflect(inRay.direction, hit.normal);
        Ray reflectionRay;

        if (rand() < specChance) {
            //specular reflection
            const float alpha = 300000.f;
            const float scaling = (alpha + 2) / (alpha + 1);

            const float3 rayDirection = SampleHemisphere(reflected, alpha);
            reflectionRay = CreateRay(rayOrigin, rayDirection, RAYTYPE_REFLECTION);


            reflectionRay.energy = inRay.energy * mat.specular / specChance * sdot(hit.normal, rayDirection, scaling);
        }
        else {
            //diffuse reflection
            const float3 rayDirection = SampleHemisphere(hit.normal, 1.0f);
            reflectionRay = CreateRay(rayOrigin, rayDirection, RAYTYPE_REFLECTION);
            reflectionRay.energy = inRay.energy * mat.albedo / diffChance;
        }

        rb.Push(reflectionRay);
    }*/

    void LoadTextures(inout MaterialBufferObject mat, inout RayHit hit)
    {
        if(mat.albedoTexId >= 0)
        {
            mat.albedo = _MaterialAlbedoTextures.SampleLevel(sampler_MaterialAlbedoTextures, float3(hit.uv, mat.albedoTexId),
            0).xyz;
        }
        if(mat.emissionTexId >= 0)
        {
            mat.emission = _MaterialEmissionTextures.SampleLevel(sampler_MaterialEmissionTextures, float3(hit.uv, mat.emissionTexId),
            0).xyz;
        }
        if(mat.normalTexId >= 0)
        {
           /*
           const float3 bitangent = cross(hit.normal, hit.tangent);
            const float3x3 tbnMat = float3x3(hit.tangent, bitangent, hit.normal);
            const float3 bumpmapNormal = normalize(_MaterialNormalTextures.SampleLevel(sampler_MaterialNormalTextures, float3(hit.uv, mat.normalTexId),
                0).xyz * 2.0 - 1.0);
            hit.normal += mul(tbnMat, bumpmapNormal);*/
        }
        if(mat.MRTexId >= 0)
        {
            float2 MR = _MaterialMRTextures.SampleLevel(sampler_MaterialMRTextures, float3(hit.uv, mat.MRTexId),
            0).ra;
            mat.metalness = MR.x;
            mat.roughness = MR.y;
        }
    }

    void EvaluateCookTorrance(const MaterialBufferObject mat, const Ray inRay, const RayHit hit, inout RayBuffer rb, inout float3 attenuation)
    {
        const float3 rayOrigin = hit.position + hit.normal * 0.0001f;
        const float3 reflected = reflect(inRay.direction, hit.normal);
        Ray reflectionRay;

        const float3 V = -inRay.direction;
        float3 F0 = float3(0.04, 0.04, 0.04);
        F0 = lerp(F0, mat.albedo, mat.metalness);

        float3 rayDirection = SampleHemisphere(hit.normal);

#ifdef USE_LIGHTS
        const int samplingStrats = 2;
        const int lightId = GetRandomLightID();
#else
        const int samplingStrats = 1;
#endif
        
        const int SamplingStrategy = randInt(0, samplingStrats);
        
        if(SamplingStrategy == 0)
        {
            rayDirection = SampleCT(reflected, mat.roughness);
        }
#ifdef USE_LIGHTS
        else if(SamplingStrategy == 1)
        {
            rayDirection = SampleLight(lightId, rayOrigin);
        }
#endif
        
        const float3 H = halfVector(rayDirection, V);
        const float3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);

        const float specChance = max(F.x, max(F.y, F.z));
        
        if (rand() < specChance)
        { //specular
            reflectionRay = CreateRay(rayOrigin, rayDirection, RAYTYPE_REFLECTION);

            const float D = NDF_GGX(hit.normal, H, mat.roughness);
            const float G = GeometrySmith(hit.normal, V, rayDirection, mat.roughness);

            const float3 numerator = D * F * G;
            const float denominator = 4.0 * max(dot(hit.normal, V), 0.0) * max(dot(hit.normal, reflectionRay.direction), 0.0) + 0.00001;

            reflectionRay.energy = inRay.energy * numerator * mat.albedo / (denominator * specChance);
            if(SamplingStrategy == 0)
                reflectionRay.energy /= abs(D * dot(H, hit.normal));
        }
        else {
            //diffuse
            const float kd = (1.0 - specChance);
            reflectionRay = CreateRay(rayOrigin, rayDirection, RAYTYPE_REFLECTION);
            reflectionRay.energy = inRay.energy * 2.0 / kd *  mat.albedo * sdot(hit.normal, rayDirection); ;

        }

        reflectionRay.energy *= samplingStrats;

#ifdef USE_RR
        float surv_Chance = max(reflectionRay.energy.x, max(reflectionRay.energy.y, reflectionRay.energy.z));
        if(rand()>surv_Chance)
        {
            return;
        }
        reflectionRay.energy *= 1.0 / surv_Chance;
#endif

        if(SamplingStrategy == 0)
        {
            reflectionRay.type = RAYTYPE_REFLECTION;
            rb.Push(reflectionRay);
        }
#ifdef USE_LIGHTS
        else if(SamplingStrategy == 1)
        {
            attenuation = reflectionRay.energy * GetContribution(lightId, reflectionRay);
        }
#endif
    }

    bool Scatter(Ray inRay, inout RayHit hit, inout float3 attenuation, inout RayBuffer rb)
    {
        MaterialBufferObject mat = _Materials[hit.matID];
        LoadTextures(mat, hit);

        attenuation = 0;
        
        if (!hit.isFrontFace)
            hit.normal = -hit.normal;
            

        if ( any(mat.albedo))
        {
            EvaluateCookTorrance(mat, inRay, hit, rb, attenuation);
        }
        else if (any(mat.transmission))
        {
            float3 rayOrigin = hit.position - hit.normal * 0.0001f;

            float refractive_index = hit.isFrontFace ? 1.0 / mat.ior : mat.ior;
            float cos_theta = min(dot(inRay.direction, -hit.normal), 1.0);
            float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

            bool cannot_refract = sin_theta * refractive_index > 1.0;
            float Schlick_term = Schlicks_Approx(cos_theta, refractive_index);

            float3 rayDirection;

            if (cannot_refract || Schlick_term > rand())
            {
                rayOrigin = hit.position + hit.normal * 0.0001f;
                rayDirection = reflect(inRay.direction, hit.normal);
            }
            else
            {
                rayDirection = refract(inRay.direction, hit.normal, refractive_index);
            }


            Ray transmissionRay = CreateRay(rayOrigin, rayDirection, RAYTYPE_TRANSMISSION);
            transmissionRay.energy = inRay.energy * mat.transmission;
            rb.Push(transmissionRay);
        }
        if (any(mat.emission))
        {
            attenuation = mat.emission;
        }
        
        return true;
    }
};
//=======================================
//=-------------------------------------=
//=------------OBSOLETE-----------------=
//=-------------------------------------=
//=======================================
/*class PerfectMirror : iMaterial
{
	
    float3 albedo;
    bool Scatter(Ray inRay, RayHit hit, inout float3 attenuation, inout Ray scatteredRay)
    {
        scatteredRay.origin = hit.position + hit.normal * 0.0001f;
        scatteredRay.direction = reflect(inRay.direction, hit.normal);
        scatteredRay.energy = inRay.energy * albedo;
        attenuation = float3(0.0f, 0.0f, 0.0f);
        return true;
    }
};

PerfectMirror CreateMirror(float3 color)
{
    PerfectMirror a;
    a.albedo = color;
    return a;
}

class LambertianDiffuse : iMaterial
{
    float3 albedo;

    bool Scatter(Ray inRay, RayHit hit, inout float3 attenuation, inout Ray scatteredRay)
    {
        scatteredRay.origin = hit.position + hit.normal * 0.0001f;
        scatteredRay.direction = SampleHemisphere(hit.normal);
        scatteredRay.energy = inRay.energy * 2.0f * albedo * saturate(dot(hit.normal, scatteredRay.direction));
        attenuation = float3(0.0f, 0.0f, 0.0f);
        return true;
    }
};

LambertianDiffuse CreateLambertian(float3 color)
{
    LambertianDiffuse a;
    a.albedo = color;
    return a;
}

class Emissive : iMaterial
{
    float3 emissive;
    
    bool Scatter(Ray inRay, RayHit hit, inout float3 attenuation, inout Ray scatteredRay)
    {
        scatteredRay.energy = float3(0.0f, 0.0f, 0.0f);
        attenuation = emissive;
        return true;
    }
};

Emissive CreateEmissive(float3 color)
{
    Emissive a;
    a.emissive = color;
    return a;
}*/
#endif